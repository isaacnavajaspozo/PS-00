===========================================================================================================
=============[ K  U  M  A ]================================================================================

# update software repositories
sudo apt update

# install available software updates
sudo apt upgrade -y

# install prerequisites
sudo apt install git curl -y

# add nodejs software repository
curl -sL https://deb.nodesource.com/setup_current.x | sudo bash -

# install nodejs
sudo apt install nodejs -y

# clone from git
git clone https://github.com/louislam/uptime-kuma.git ./uptime-kuma

# change directory to ./uptime-kuma
cd uptime-kuma

# run setup
npm run setup

# run uptime kuma
node server/server.js

# pruebo que puedo entrar en la web
http://<IP-SERVER>:3001

# create nodejs user
sudo useradd nodejs

# change directory out of uptime-kuma
cd ..

# move uptime kuma to /opt
sudo mv ./uptime-kuma /opt

# create service bash file
sudo nano /opt/uptime-kuma/uptime-kuma.sh
---------------------------------------------------------------------
#!/usr/bin/bash
/usr/bin/node /opt/uptime-kuma/server/server.js
---------------------------------------------------------------------

# make uptime-kuma.sh executable
sudo chmod +x /opt/uptime-kuma/uptime-kuma.sh

# create uptime-kuma service file
sudo nano /etc/systemd/system/uptime-kuma.service
---------------------------------------------------------------------
[Unit]
Description=uptime-kuma

[Service]
ExecStart=/opt/uptime-kuma/uptime-kuma.sh
Restart=always
User=nodejs
Group=nodejs
WorkingDirectory=/opt/uptime-kuma

[Install]
WantedBy=multi-user.target
---------------------------------------------------------------------

# set owner of /opt/uptime-kuma
sudo chown nodejs:nodejs /opt/uptime-kuma -R

# reload systemd services
sudo systemctl daemon-reload

# start uptime-kuma service on boot and now
sudo systemctl enable uptime-kuma --now

# ⚠️ la primera vez que entro en la web tengo que crear la cuenta si no lo recuerdo puedo lanzar el siguiente comando
# cd /opt/uptime-kuma
# node server/server.js reset-password

# Configuración en el entorno web
Ajustes > Notificaciones > Configuración notificación
---------------------------------------------------------------------
Tipo de notificación: Email (SMTP)
Nombre sencillo: Gmail Alert
Nombre del host: smtp.gmail.com
Puerto: 465
Seguridad: TLS (465)
Usuario: <correo-gmail>
Contraseña: <contraseña-de-aplicacion-de-gmail>
Asunto Personalizado: 🔔📜 Alerta de monitor | PROXMOX  · root箱[MyKuma] 
[x] Habilitado por defecto
[x] Aplicar en todos los monitores existentes
---------------------------------------------------------------------

# creo un nuevo panel
Añadir nuevo panel
---------------------------------------------------------------------
Tipo de monitor: Ping
Nombre sencillo: <nombre>
Nombre del host: <ip-del-servidor-a-monitorizar>
---------------------------------------------------------------------

# Finalmente en GMAIL creo una etiqueta con el nombre "🔔📜 PROXMOX" y una regla que todos que tengan el asunto "🔔📜 Alerta de monitor", para que los envie a la etiqueta para poder borrarlos de forma masiva
 

=========================================================================================================
# 🧮 aviso del servidor por CPU [monitorización - sobrecalentamiento mini-pc-servidor]:

# instalando paquetes
sudo apt update
sudo apt install postfix sensors -y

# compruebo estado
systemctl status postfix

# copio la version antigua del archivo
cp /etc/postfix/main.cf /etc/postfix/main.cf.old
vim /etc/postfix/main.cf
---------------------------------------------------------------------
relayhost = [smtp.gmail.com]:587
smtp_use_tls = yes
smtp_sasl_auth_enable = yes
smtp_sasl_password_maps = hash:/etc/postfix/sasl_passwd
smtp_sasl_security_options = noanonymous
smtp_tls_CAfile = /etc/ssl/certs/ca-certificates.crt
smtp_address_preference = ipv4
---------------------------------------------------------------------

# agrego credenciales
vim /etc/postfix/sasl_passwd
---------------------------------------------------------------------
[smtp.gmail.com]:587 tu_correo@gmail.com:tu_contraseña_o_clave_de_aplicación
---------------------------------------------------------------------

# doy permisos 
chmod 600 /etc/postfix/sasl_passwd

# compatibilidad de postfix por una versión reciente y estable
postconf compatibility_level=3.6

# recargo servicio
sudo postfix reload

# enviar correo
echo "Correo de prueba enviado desde Postfix usando Gmail" | mail -s "Prueba Exitosa" destinatario@gmail.com

# comprobar que se a enviado
mailq                                 # Ver cola
tail -f /var/log/mail.log             # Ver envíos en tiempo real y comprobar fallos

# desarrollo el script para avisar si la CPU sobrepasa los 80º (con el comando sensors)
vim /usr/local/bin/check_temp_loop.sh
---------------------------------------------------------------------
#!/bin/bash
GMAIL_TO="destino@gmail.com"
TEMP_LIMIT=30.0
SLEEP_INTERVAL=60                                                       # espera 60 segundos (1 minuto)
ALERT_INTERVAL=1200                                                     # enviará una alerta y luego esperará 1200 segundos (que son 20 minutos) antes de enviar otra alerta
TIMESTAMP_FILE="/usr/local/bin/cpu_alert_timestamp"                     # último momento en que se envió una alerta

TIMESTAMP_FILE="/tmp/cpu_alert_timestamp"

while true; do
    temp=$(sensors | awk '/Package id 0/ {gsub(/\+|°C/, "", $4); print $4; exit}')
    [[ -z "$temp" ]] && temp=$(sensors | awk '/Core 0/ {gsub(/\+|°C/, "", $3); print $3; exit}')

    if [[ -z "$temp" ]]; then
        echo "[$(date)] No se pudo leer la temperatura." >> /var/log/check_temp_loop.log
    elif (( $(echo "$temp > $TEMP_LIMIT" | bc -l) )); then
        now=$(date +%s)
        last_alert=0
        [[ -f "$TIMESTAMP_FILE" ]] && last_alert=$(cat "$TIMESTAMP_FILE")

        if (( now - last_alert > ALERT_INTERVAL )); then
            echo "[$(date)] Temperatura alta: $temp°C. Enviando alerta..." >> /var/log/check_temp_loop.log
            echo -e "⚠️ ALERTA:\n\nLa CPU de $(hostname) ha alcanzado los $temp°C.\nEl siguiente mensaje no se volverá a mandar hasta los 20 minutos después (aunque aumente la temperatura).\n\nÚltimas 20 líneas del log:\n***********************************************************************************\n$(tail -n 20 /var/log/check_temp_loop.log)\n" | mail -s "🔔⚠️ Alerta de monitor.proxmox - [CPU: $temp°C]" "$GMAIL_TO"
            echo "$now" > "$TIMESTAMP_FILE"
        fi
    else
        [[ -f "$TIMESTAMP_FILE" ]] && rm "$TIMESTAMP_FILE"
    fi

    sleep "$SLEEP_INTERVAL"
done
---------------------------------------------------------------------

# doy permisos 
chmod +x /usr/local/bin/check_temp_loop.sh

# creo un systemd para lectura continua del servicio
vim /etc/systemd/system/check_temp.service
---------------------------------------------------------------------
[Unit]
Description=monitor-cpu
After=network.target

[Service]
ExecStart=/usr/local/bin/check_temp_loop.sh
Restart=always
RestartSec=5
User=root

[Install]
WantedBy=multi-user.target
---------------------------------------------------------------------

# Recargar systemd
systemctl daemon-reexec
systemctl daemon-reload

# Habilitar e iniciar
systemctl enable --now check_temp.service

# Ver estado
systemctl status check_temp.service


























# instalo dependencias
apt install postfix mailutils libsasl2-modules bc

# devuelve el numero de grados del CPU 
sensors | awk '/Package id 0/ {print $4; exit}'
#  +44.0°C

# creo el archivo para configurar snmp gmail
vim /etc/postfix/main.cf
---------------------------------------------------------------------
relayhost = [smtp.gmail.com]:587

smtp_sasl_auth_enable = yes
smtp_sasl_security_options = noanonymous
smtp_sasl_password_maps = hash:/etc/postfix/sasl_passwd

smtp_tls_security_level = encrypt
smtp_tls_CAfile = /etc/ssl/certs/ca-certificates.crt
smtp_tls_session_cache_database = btree:${data_directory}/smtp_scache
---------------------------------------------------------------------

# 
vim /etc/postfix/sasl_passwd
---------------------------------------------------------------------
[smtp.gmail.com]:587 tu-correo@gmail.com:contraseña-app
---------------------------------------------------------------------

# doy permisos
chmod 600 /etc/postfix/sasl_passwd
postmap /etc/postfix/sasl_passwd
chown root:root /etc/postfix/sasl_passwd /etc/postfix/sasl_passwd.db
systemctl restart postfix

# pruebo
echo "Mensaje de alerta" | mail -s "Asunto" destino@gmail.com

# desarrollo el script
vim /usr/local/bin/check_temp_loop.sh
---------------------------------------------------------------------
#!/bin/bash
GMAIL_TO="destino@gmail.com"
TEMP_LIMIT=80.0
SLEEP_INTERVAL=60
ALERT_INTERVAL=2400
TIMESTAMP_FILE="/tmp/cpu_alert_timestamp"

while true; do
    temp=$(sensors | awk '/Package id 0/ {gsub(/\+|°C/, "", $4); print $4; exit}')
    [[ -z "$temp" ]] && temp=$(sensors | awk '/Core 0/ {gsub(/\+|°C/, "", $3); print $3; exit}')

    if [[ -z "$temp" ]]; then
        echo "[$(date)] No se pudo leer la temperatura." >> /var/log/check_temp_loop.log
    elif (( $(echo "$temp > $TEMP_LIMIT" | bc -l) )); then
        now=$(date +%s)
        last_alert=0
        [[ -f "$TIMESTAMP_FILE" ]] && last_alert=$(cat "$TIMESTAMP_FILE")

        if (( now - last_alert > ALERT_INTERVAL )); then
            echo "[$(date)] Temperatura alta: $temp°C. Enviando alerta..." >> /var/log/check_temp_loop.log
            echo -e "⚠️ ALERTA:\n\nLa CPU de $(hostname) ha alcanzado los $temp°C." | mail -s "⚠️ ALERTA CPU - $(hostname)" "$GMAIL_TO"
            echo "$now" > "$TIMESTAMP_FILE"
        fi
    else
        [[ -f "$TIMESTAMP_FILE" ]] && rm "$TIMESTAMP_FILE"
    fi

    sleep "$SLEEP_INTERVAL"
done
---------------------------------------------------------------------

# doy permisos 
chmod +x /usr/local/bin/check_temp_loop.sh

# creo un systemd para lectura continua del servicio
vim /etc/systemd/system/check_temp.service
---------------------------------------------------------------------
[Unit]
Description=monitor-cpu
After=network.target

[Service]
ExecStart=/usr/local/bin/check_temp_loop.sh
Restart=always
RestartSec=5
User=root

[Install]
WantedBy=multi-user.target
---------------------------------------------------------------------

# Recargar systemd
systemctl daemon-reexec
systemctl daemon-reload

# Habilitar e iniciar
systemctl enable --now check_temp.service

# Ver estado
systemctl status check_temp.service


=========================================================================================================
# proyecto con esp [monitorización - antirobos]:
# una de estas dos esp (porque son mis favoritas y baratas), y el sensor de movimientos soldado 
- esp8266 LOLIN(WEMOS) D1 R2 & mini
- esp8266 D1 mini
  + sensor PIR HC-SR501  # sensor movimiento
  + DHT22 / AM2302       # sensor temperatura

+------------+---------------------+-------------------------------+
| HC-SR501   | ESP8266 D1 mini     | Descripción                   |
+------------+---------------------+-------------------------------+
| VCC        | Vin (5V)            | Alimentación                  |
| GND        | GND                 | Tierra                       |
| OUT        | D5 (GPIO14)         | Señal digital del sensor      |
+------------+---------------------+-------------------------------+

# esta sin terminar porque quiero hacer también un servidor web que registre temperatura
# Código Arduino IDE para ESP8266 D1 mini + HC-SR501 + envío Gmail SMTP
# arduino IDE - descargar librería : ESP_Mail_Client
---------------------------------------------------------------------
#include <ESP8266WiFi.h>
#include <ESP_Mail_Client.h>

// --- Config WiFi ---
const char* ssid = "TU_SSID";
const char* password = "TU_PASSWORD";

// --- Config SMTP ---
#define SMTP_HOST "smtp.gmail.com"
#define SMTP_PORT 587
#define AUTHOR_EMAIL "tucorreo@gmail.com"
#define AUTHOR_PASSWORD "tu_app_password"

// Destinatario
#define RECIPIENT_EMAIL "destino@gmail.com"

// Pin sensor PIR
#define PIR_PIN D5

// Variables
bool lastState = false;

// SMTP Session
SMTPSession smtp;

void smtpCallback(SMTP_Status status) {
  Serial.println(status.info());
}

void setup() {
  Serial.begin(115200);
  pinMode(PIR_PIN, INPUT);

  WiFi.begin(ssid, password);
  Serial.print("Conectando a WiFi...");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("Conectado!");

  // Configurar sesión SMTP
  smtp.debug(1);
  ESP_Mail_Session session;
  session.server.host_name = SMTP_HOST;
  session.server.port = SMTP_PORT;
  session.login.email = AUTHOR_EMAIL;
  session.login.password = AUTHOR_PASSWORD;
  session.login.user_domain = "";

  smtp.callback(smtpCallback);
  smtp.session.setSession(session);
}

void loop() {
  bool motionDetected = digitalRead(PIR_PIN) == HIGH;

  if (motionDetected && !lastState) {
    Serial.println("Movimiento detectado, enviando email...");
    sendEmail();
    lastState = true;
  } else if (!motionDetected && lastState) {
    Serial.println("Sin movimiento");
    lastState = false;
  }

  delay(500); // Anti-rebote simple
}

void sendEmail() {
  SMTP_Message message;

  message.sender.name = "ESP8266 PIR Sensor";
  message.sender.email = AUTHOR_EMAIL;
  message.subject = "Alerta: Movimiento Detectado!";
  message.addRecipient("Destinatario", RECIPIENT_EMAIL);

  message.text.content = "Se ha detectado movimiento en el sensor PIR HC-SR501 conectado al ESP8266.";

  if (!smtp.connect()) {
    Serial.println("Error conectando al servidor SMTP");
    return;
  }

  if (!MailClient.sendMail(&smtp, &message)) {
    Serial.println("Error enviando email, " + smtp.errorReason());
  } else {
    Serial.println("Email enviado!");
  }
}
---------------------------------------------------------------------

# Crear nuevo monitor :: configurar un ping a la esp para saber si esta apagada o encendida
- de la misma manera que en la parte de arriba con PING

# Crear nuevo monitor :: configurar si la respuesta HTTP contiene un texto específico para comprobar movimiento a nivel de Kuma
---------------------------------------------------------------------
Tipo: HTTP(s)
Método: GET
URL: http://tu_ip_esp:puerto/estado
(ej: http://192.168.1.100:8080/estado)
Configura opciones básicas:
Nombre: Sensor Movimiento
Intervalo: lo que quieras (ej: 60s)
Activar la opción de palabra clave (Keyword):
Marca la opción "Enable keyword check"
En el campo Keyword, escribe:
on
(o lo que deba contener la respuesta)
# si no devuelve la web la palabra on se caera la monitorización
---------------------------------------------------------------------

#    HTTP 200 OK con body: "on"	 ✅ UP
#    HTTP 200 OK con body: "off" ❌ DOWN








===========================================================================================================
=============[ N  E  T  D  A  T  A  ]======================================================================

# ⚠️ este es otro paquete distinto a Kuma pero igualmente para monitorizar
# ⚠️ lo dejo documentado pero no lo instalo, sirve de reeplazo si no quiero kuma
https://learn.netdata.cloud/docs/netdata-agent/installation/linux/offline-systems

# preparo el paquete de instalación
curl https://get.netdata.cloud/kickstart.sh > /tmp/netdata-kickstart.sh
sh /tmp/netdata-kickstart.sh --release-channel stable --prepare-offline-install-source ./netdata-offline

# realizo la instalación
cd /netdata-offline
./kickstart.sh
./install.sh

# entro en la web
http://<IP-SERVER>:19999/
# dentro de la web, página principal hay que pulsar en : Skip and use the dashboard anonymously.
